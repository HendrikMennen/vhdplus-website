"use strict";
/**
 * Copyright (c) 2017-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const { parseQuery, getOptions } = require('loader-utils');
const blogUtils_1 = require("./blogUtils");
const path_1 = __importDefault(require("path"));
const fs_extra_1 = require("fs-extra");
const utils_1 = require("@docusaurus/utils");
module.exports = function (fileString) {
    const callback = this.async();
    const { truncateMarker, siteDir, dataDir } = getOptions(this);
    let finalContent = fileString;
    // Truncate content if requested (e.g: file.md?truncated=true)
    const { truncated } = this.resourceQuery && parseQuery(this.resourceQuery);
    if (truncated) {
        finalContent = blogUtils_1.truncate(fileString, truncateMarker);
    }
    // Read metadata & then embed it to this markdown content
    // Note that metadataPath must be the same/ in-sync as the path from createData
    const aliasedSource = utils_1.aliasedSitePath(this.resourcePath, siteDir);
    const metadataPath = path_1.default.join(dataDir, `${utils_1.docuHash(aliasedSource)}.json`);
    // Add metadataPath as dependency of this loader result so that we can recompile if metadata is changed
    this.addDependency(metadataPath);
    fs_extra_1.readFile(metadataPath, 'utf8', function (err, metadata) {
        if (err)
            return callback && callback(err);
        const metadataStr = `export const metadata = ${metadata};`;
        // We need to add two lines break so that mdx won't mistake it as part of previous paragraph
        callback && callback(null, finalContent + '\n\n' + metadataStr);
    });
};
